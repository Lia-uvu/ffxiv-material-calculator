# 设计决策记录（Decision Log）

> 记录项目中比较重要的设计选择，以及当时的原因。  
> 小改小动（比如变量名微调）不在这里记。

---

## 2025-12-02：统一使用 number 类型 ID

**类型**：数据模型 / 约定  
**结论**：所有 ID（`Item.id` / `Recipe.id` / `resultItemId` / `materials[].itemId`）统一使用 `number` 类型，而不是字符串形式的数字。

**原因**：
- 上游数据源（FF14 API / Wiki 等）大多使用数字 ID，映射时不需要频繁做类型转换。
- 方便在代码中使用 `Map<number, Item>` 等结构，避免 string/number 混用导致的 bug。
- 当前项目仍处于早期阶段，在此时统一规范，可以避免后续进行成本较大的迁移。

**影响**：
- 清洗外部数据时，如果源数据为字符串 ID，需要在导入时显式转换为 number。
- 前端代码中禁止使用 `"4421"` 这类字符串 ID 作为内部约定。

**状态**：有效

---

## 2025-12-02：拆分 Item 与 Recipe 两类实体

**类型**：数据模型 
**结论**：将游戏数据拆分为两类实体：
- `Item`：只描述物品本身的信息（名称、是否为水晶、获取方式等）。
- `Recipe`：只描述一次制作行为（“用哪些材料 → 产出哪个成品”）。

**原因**：
- 让 `Recipe` 结构保持瘦且稳定，未来扩展 `Item` 信息时不需要修改所有配方。
- 配方树计算逻辑只依赖 ID 关系（`resultItemId` 和 `materials[].itemId`），降低耦合度。
- 便于在 `Item` 上逐步增加字段（采集点、NPC、分类等），而不让 `Recipe` 变得臃肿。

**影响**：
- 数据清洗脚本在导入时需要分别生成 `items.json` 与 `recipes.json`。
- 前端在展示配方时，需要通过 `itemId` 去 `Item` 表查物品信息，不再从 `Recipe` 中直接读取名称等属性。

**状态**：有效

---

## 2025-12-11：确认单向数据流设计
**类型**：架构  
**结论**：将游戏数据拆分为视图方向（下行）和事件方向（上行）：
- 视图方向（下行）：Settings Store → Page → 子组件（props）
- 事件方向（上行）：子组件（emit） → Page → Settings Store
data文件夹内只存静态数据，动态数据保存在settingStore.js里，放在负责组件逻辑(动态)的composables文件夹内

**原因**：
- 确保CalculatorPage.vue CalculatorPage 做的事情非常单纯：
  把 settings 拆成不同 props 给小组件；
  把小组件 emit 回来的事件转成对 settings 的修改。
  它自己不需要有额外的业务状态，只有 “引入哪个组件 & 怎么连线” 这种“页面配置”的职责
- 区分静态数据和动态数据

**影响**：
- props和emit等数据输入需要检查是否符合数据流顺序

**状态**：有效

---

## 2025-12-12：settingStore设置
**类型**：代码规范
**结论**：settings给只读，只能通过函数修改setting的值

**原因**：只暴露 settings + “改它的函数”，能强迫保持“上行必须走函数/事件”，避免不小心到处改 state。

**影响**：
- 组件emit提交给pages，再由pages调用settingStore里export的修改函数

**状态**：有效

## 2025-12-14：查询清洗分层设计（UI / Store / Core）

**类型**：数据流 / 状态管理  

**结论**：  
将搜索 query 的处理拆分为三层：

1. `SearchBar`（UI 层）：只做「输入体验」相关的清洗和防抖。
2. store 的 `setSearchQuery()`（状态层）：做最终统一清洗（长度、`trim` 等），是所有入口写 query 的必经之路。
3. `calcMaterials()` 等核心函数（业务层）：只解释 query 的业务含义并计算结果，不再做字符串级清洗。

---

**原因**：  
- 未来 query 可能来自多个入口：  
  - 搜索框输入；  
  - 最近搜索按钮；  
  - URL 参数（`?q=`）；  
  - 快捷键预填默认值等。  
- 如果只在某个组件里做“最终清洗”，其它入口就会绕过这套规则，导致状态不一致。  
- 清晰的分层有利于维护：  
  - UI 可以随意迭代体验；  
  - Store 层保证数据合法性；  
  - Core 层只专心做“同一个 query → 同一个结果”。

---

**影响**：  
- 需要新增或约定一个统一的入口方法（如 `setSearchQuery(raw)`），所有写 query 的地方都必须调用它。  
- 在调试与排查问题时，可以明确区分：  
  - 是 UI 层的输入体验问题；  
  - 还是状态层的清洗规则问题；  
  - 还是业务计算本身的问题。  
- 核心计算函数可以假设传入的 query 已满足最基本的格式要求，降低防御性代码的重复。

---

**状态**：有效  

---

## 2025-12-14：防御式设计：规则不只依赖 UI

**类型**：架构原则 / 约定  

**结论**：  
所有影响**结果正确性**的规则（例如大小写是否敏感、分词/匹配策略、别名处理、多语言匹配方式等），必须在 Store / Core 这类业务层集中实现，而不能只通过 UI 限制来保证。

---

**原因**：  
- UI 只是众多入口之一，不能成为唯一的“守门人”。  
- 用户可以通过不同途径触发计算（URL、快捷操作、未来的移动端 UI 等），如果有逻辑只写在某个组件里，很容易被绕过。  
- 把正确性规则收拢到业务层，便于统一修改与测试，减少“改了一处，忘了别的入口”的坑。

---

**影响**：  
- 在设计新功能时，需要明确标记哪些规则属于“体验级”（只影响好不好用），哪些属于“正确性级”（会影响结果是否可信）。  
- 正确性级规则一律下沉到 Store / Core，UI 层只做补充和优化，而不是唯一保障。  
- 单元测试主要覆盖 Store / Core 中的规则实现，而不是依赖组件行为来间接验证。

---

**状态**：有效  

---

## 2025-12-14：核心计算函数保持纯函数

**类型**：架构 / 代码组织  

**结论**：  
`calcMaterials()` 等核心计算逻辑保持为**纯函数**：  
- 只通过参数获取输入，不直接读取 Vue 组件实例或全局 store；  
- 只通过返回值输出结果，不在内部修改外部状态。

---

**原因**：  
- 便于编写单元测试：在没有 Vue 环境的情况下也可以直接跑逻辑。  
- 方便未来复用：  
  - 可以在 CLI、服务端、其它前端项目中复用同一套计算逻辑；  
  - 不被当前 UI 技术栈绑死。  
- 降低耦合：展示层只负责“喂数据 / 拿结果 / 渲染”，业务层专注“给定输入 → 算出输出”。

---

**影响**：  
- 需要设计统一的数据结构作为函数参数，例如：  
  - `targetItems`（成品清单）；  
  - `items`、`recipes` 数据表；  
  - `options`（计算选项）。  
- 组件内如果需要依赖计算结果，应该通过调用这些纯函数，并在组件外/调用处处理异常与状态更新。  
- 当计算逻辑变更时，可以在不修改组件的前提下，通过调整纯函数来实现。

---

**状态**：有效  

---

## 2025-12-14：成品清单作为唯一计算入口

**类型**：数据模型 / 接口设计  

**结论**：  
核心计算只接受统一结构的「成品清单」作为入口，例如：

```ts
type TargetItem = {
  itemId: number;
  quantity: number;
};

type TargetItemList = TargetItem[];
```

无论成品是通过搜索、最近记录、预设方案还是其它方式选择的，只要能产出 `TargetItemList`，就可以复用同一套材料计算逻辑。

---

**原因**：  
- 解耦「如何选择成品」与「如何计算材料」这两类逻辑：  
  - 选择成品可以有多种 UI/交互形态；  
  - 计算材料只关心 ID 和数量。  
- 方便扩展新的入口：  
  - 日后可以增加「一键选择套装」「读取上次记录」等功能，只需要产出同样结构的清单即可。  
- 使 core 层 API 更稳定：需求变化时，尽量只改 UI 层和清单生成逻辑，而不是频繁改动计算函数签名。

---

**影响**：  
- 成品列表 / 目标成品面板需要负责把用户操作（选择、数量调整）整理成 `TargetItemList`。  
- 计算入口函数（如 `calcMaterials(targetItems, items, recipes, options)`）不再接受“散装参数”，而是依赖这份清单。  
- 测试时可以直接构造不同的 `TargetItemList` 来覆盖多种场景（单成品、多成品、大数量、混合配方等）。

---

**状态**：有效  
