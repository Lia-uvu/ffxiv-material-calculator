# Roadmap / 版本更迭记录（含草案）

> 本文档描述项目各版本的目标与计划中的功能。  
> 当前已经实现的结构细节与行为，请参考：`docs/architecture.zh-CN.md`。  
> 设计决策与取舍记录见：`docs/decisions.zh-CN.md`。

---

## v1.0-基础功能
> 数据流程（确保单个测试用例能跑通）
- 搜索框：可以根据键入信息匹配到对应的成品，传递给成品列表
- 成品列表：根据搜索框传入的物品信息+用户编辑的数量，生成成品列表
- core.js：根据成品列表传入的信息，访问data查询，计算出材料列表
- 材料树逻辑js：导入core.js的输出表格，导入小组件记录的状况（这里要不要找个文件暂存）



✅ SearchBar.vue 适合放这些（纯“展示/交互层”的清洗）
这些属于“让输入框好用、好看、不卡”的处理：
去掉你不想让用户输入的字符（比如换行、制表符）
把连续空白合并成一个空格（可选）
防抖（因为它是交互体验问题）
输入法期间（中文输入法 composition）不要乱触发更新（体验问题）
这些处理的共同点：影响的是“输入框怎么表现”。

✅ calcMaterials.js 适合放这些（纯“业务/计算层”的处理）
这些属于“你到底怎么理解这个 query，并据此算什么”：
大小写是否忽略、是否做 normalize
分词/匹配规则（前缀、模糊、拼音、别名、中文/英文混输怎么处理）
根据 query 过滤候选 item、选中 item 后怎么展开材料树
任何会影响“结果正确性”的规则
这些处理的共同点：同一个 query，无论从哪里来，结果都应该一致。

⚠️ 我唯一会拦你一下的点：别把“最终清洗规则”只放在 SearchBar
原因很简单：以后你可能不止一个入口能改这个 query：
你可能加一个“最近搜索”按钮，一点就把 query 塞进去
你可能把 query 从 URL ?q= 初始化
你可能做快捷键 / 聚焦搜索并设置默认值
如果“最终清洗”只在 SearchBar 里，那这些入口就会绕过它，状态就不一致了。
所以最稳的做法是：双层
SearchBar：做“输入框体验层”的清洗（可有可无，但很舒服）
Store 的 setSearchQuery()：做“最后一道闸”（保证任何入口写进来的都合规）
core：做“业务解释 + 计算”，尽量保持纯函数
这叫“防御式”：UI 可以友好，但规则不能只靠 UI 保证。

一个很具体的落地例子（你就照这个想）
SearchBar 内部：把 \n 干掉、合并空格、（可选）防抖后 emit
Page：接到 emit → 调 setSearchQuery()
setSearchQuery()：再 .trim() + 长度限制（最终统一）
calcMaterials(query, items, recipes, options)：纯计算，不碰 Vue，不碰 store